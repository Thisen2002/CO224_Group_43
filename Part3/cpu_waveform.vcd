$date
	Wed May 28 06:48:24 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module top_level_cpu_tb $end
$var wire 32 ! PC [31:0] $end
$var reg 1 " CLK $end
$var reg 32 # INSTRUCTION [31:0] $end
$var reg 1 $ RESET $end
$scope module uut $end
$var wire 1 " CLK $end
$var wire 32 % INSTRUCTION [31:0] $end
$var wire 1 $ RESET $end
$var wire 3 & WRITEREG [2:0] $end
$var wire 1 ' WRITEENABLE $end
$var wire 8 ( TWOSOUT [7:0] $end
$var wire 1 ) SIGN $end
$var wire 8 * REGOUT2 [7:0] $end
$var wire 8 + REGOUT1 [7:0] $end
$var wire 3 , READREG2 [2:0] $end
$var wire 3 - READREG1 [2:0] $end
$var wire 8 . OPCODE [7:0] $end
$var wire 8 / MUXOUT2 [7:0] $end
$var wire 8 0 MUXOUT1 [7:0] $end
$var wire 8 1 IMMEDIATE [7:0] $end
$var wire 1 2 IMM $end
$var wire 8 3 ALURESULT [7:0] $end
$var wire 3 4 ALUOP [2:0] $end
$var reg 32 5 PC [31:0] $end
$var reg 32 6 PCreg [31:0] $end
$scope module alu_inst $end
$var wire 8 7 or_out [7:0] $end
$var wire 8 8 forward_out [7:0] $end
$var wire 8 9 and_out [7:0] $end
$var wire 8 : add_out [7:0] $end
$var wire 3 ; SELECT [2:0] $end
$var wire 8 < DATA2 [7:0] $end
$var wire 8 = DATA1 [7:0] $end
$var reg 8 > RESULT [7:0] $end
$scope module add $end
$var wire 8 ? RESULT [7:0] $end
$var wire 8 @ DATA2 [7:0] $end
$var wire 8 A DATA1 [7:0] $end
$upscope $end
$scope module andg $end
$var wire 8 B RESULT [7:0] $end
$var wire 8 C DATA2 [7:0] $end
$var wire 8 D DATA1 [7:0] $end
$upscope $end
$scope module fwd $end
$var wire 8 E RESULT [7:0] $end
$var wire 8 F DATA2 [7:0] $end
$upscope $end
$scope module org $end
$var wire 8 G RESULT [7:0] $end
$var wire 8 H DATA2 [7:0] $end
$var wire 8 I DATA1 [7:0] $end
$upscope $end
$upscope $end
$scope module control_inst $end
$var wire 8 J OPCODE [7:0] $end
$var wire 1 ' WRITEENABLE $end
$var wire 1 ) SIGN $end
$var wire 1 2 IMM $end
$var wire 3 K ALUOP [2:0] $end
$upscope $end
$scope module mux1 $end
$var wire 8 L DATA2 [7:0] $end
$var wire 1 2 SELECT $end
$var wire 8 M DATA1 [7:0] $end
$var reg 8 N OUTPUT [7:0] $end
$upscope $end
$scope module mux2 $end
$var wire 8 O DATA1 [7:0] $end
$var wire 1 ) SELECT $end
$var wire 8 P DATA2 [7:0] $end
$var reg 8 Q OUTPUT [7:0] $end
$upscope $end
$scope module reg_file_inst $end
$var wire 1 " CLK $end
$var wire 8 R IN [7:0] $end
$var wire 3 S INADDRESS [2:0] $end
$var wire 8 T OUT1 [7:0] $end
$var wire 3 U OUT1ADDRESS [2:0] $end
$var wire 8 V OUT2 [7:0] $end
$var wire 3 W OUT2ADDRESS [2:0] $end
$var wire 1 $ RESET $end
$var wire 1 ' WRITE $end
$upscope $end
$scope module twos_inst $end
$var wire 8 X DATA2 [7:0] $end
$var wire 8 Y OUTPUT [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx Y
bx X
b0 W
bx V
b0 U
bx T
b0 S
bx R
bx Q
bx P
bx O
bx N
bx M
b0 L
b0 K
b0 J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
b0 ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
b0 4
bx 3
02
b0 1
bx 0
bx /
b0 .
b0 -
b0 ,
bx +
bx *
0)
bx (
0'
b0 &
b0 %
1$
b0 #
0"
bx !
$end
#5
b0 6
b0 !
b0 5
1"
#6
b100 6
#8
b0 /
b0 <
b0 @
b0 C
b0 F
b0 H
b0 Q
b0 0
b0 N
b0 O
b0 X
b0 +
b0 =
b0 A
b0 D
b0 I
b0 T
b0 *
b0 M
b0 V
#9
b0 3
b0 >
b0 R
b0 7
b0 G
b0 8
b0 E
b0 (
b0 P
b0 Y
b0 9
b0 B
#10
b0 :
b0 ?
0"
0$
#15
1"
#16
b100 !
b100 5
#17
b1000 6
#20
b10101010 0
b10101010 N
b10101010 O
b10101010 X
1'
12
1)
b1 -
b1 U
b10 ,
b10 W
b1011 .
b1011 J
b10101010 1
b10101010 L
0"
b1011000000010000000010101010 #
b1011000000010000000010101010 %
#21
b1010110 /
b1010110 <
b1010110 @
b1010110 C
b1010110 F
b1010110 H
b1010110 Q
b1010110 (
b1010110 P
b1010110 Y
#22
b1010110 3
b1010110 >
b1010110 R
b1010110 7
b1010110 G
b1010110 8
b1010110 E
#23
b1010110 :
b1010110 ?
#25
1"
#26
b1000 !
b1000 5
#27
b1100 6
#30
b10 -
b10 U
b101 ,
b101 W
b1010101 0
b1010101 N
b1010101 O
b1010101 X
b1010101 1
b1010101 L
0"
b1011000000100000000001010101 #
b1011000000100000000001010101 %
#31
b10101011 /
b10101011 <
b10101011 @
b10101011 C
b10101011 F
b10101011 H
b10101011 Q
b10101011 (
b10101011 P
b10101011 Y
#32
b10101011 3
b10101011 >
b10101011 R
b10101011 7
b10101011 G
b10101011 8
b10101011 E
#33
b10101011 :
b10101011 ?
#35
1"
#36
b1100 !
b1100 5
#37
b10000 6
#40
b0 /
b0 <
b0 @
b0 C
b0 F
b0 H
b0 Q
02
0)
b1 4
b1 ;
b1 K
b11 -
b11 U
b1 &
b1 S
b10 ,
b10 W
b0 0
b0 N
b0 O
b0 X
b100001 .
b100001 J
b10 1
b10 L
0"
b100001000000110000000100000010 #
b100001000000110000000100000010 %
#41
b0 7
b0 G
b0 8
b0 E
b0 (
b0 P
b0 Y
#42
b0 3
b0 >
b0 R
b0 :
b0 ?
#45
1"
#46
b10000 !
b10000 5
#47
b10100 6
#50
1)
b100 -
b100 U
b100011 .
b100011 J
0"
b100011000001000000000100000010 #
b100011000001000000000100000010 %
#55
1"
#56
b10100 !
b10100 5
#57
b11000 6
#60
0)
b10 4
b10 ;
b10 K
b101 -
b101 U
b1000001 .
b1000001 J
0"
b1000001000001010000000100000010 #
b1000001000001010000000100000010 %
#65
1"
#66
b11000 !
b11000 5
#67
b11100 6
#70
b11 4
b11 ;
b11 K
b110 -
b110 U
b1100001 .
b1100001 J
0"
b1100001000001100000000100000010 #
b1100001000001100000000100000010 %
#75
1"
#76
b11100 !
b11100 5
#77
b100000 6
#80
b0 4
b0 ;
b0 K
b111 -
b111 U
b0 ,
b0 W
b1 .
b1 J
b0 1
b0 L
0"
b1000001110000000100000000 #
b1000001110000000100000000 %
#82
b10101011 /
b10101011 <
b10101011 @
b10101011 C
b10101011 F
b10101011 H
b10101011 Q
b10101011 0
b10101011 N
b10101011 O
b10101011 X
b10101011 *
b10101011 M
b10101011 V
#83
b10101011 3
b10101011 >
b10101011 R
b10101011 7
b10101011 G
b10101011 8
b10101011 E
b1010101 (
b1010101 P
b1010101 Y
#84
b10101011 :
b10101011 ?
#85
1"
#86
b100000 !
b100000 5
#87
b100100 6
#90
0"
#95
1"
#96
b100100 !
b100100 5
#97
b101000 6
#100
0"
#105
1"
#106
b101000 !
b101000 5
#107
b101100 6
#110
0"
#115
1"
#116
b101100 !
b101100 5
#117
b110000 6
#120
0"
#125
1"
#126
b110000 !
b110000 5
#127
b110100 6
#130
0"
